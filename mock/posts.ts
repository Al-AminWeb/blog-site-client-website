import { Post } from "@/types/post";

export const posts: Post[] = [
    {
        id: "post_1",
        title: "Understanding Prisma with Express",
        slug: "understanding-prisma-with-express",
        excerpt: "Learn how Prisma works with Express in real projects.",
        content: "Prisma is a modern database toolkit that provides a type-safe database client for Node.js. When combined with Express, it allows developers to build robust APIs with minimal boilerplate code. The integration simplifies database operations while maintaining excellent performance and type safety throughout your application.",
        coverImage: "/images/prisma.png",
        authorId: "user_1",
        status: "PUBLISHED",
        createdAt: "2025-01-10",
    },
    {
        id: "post_2",
        title: "JWT Authentication Explained",
        slug: "jwt-authentication-explained",
        excerpt: "A simple guide to JWT authentication.",
        content: "JSON Web Tokens (JWT) have become the standard for authentication in modern web applications. They consist of three parts: header, payload, and signature, each encoded in Base64Url. JWTs are stateless, meaning the server doesn't need to store session information, making them ideal for scalable distributed systems.",
        coverImage: "/images/jwt.png",
        authorId: "user_1",
        status: "PUBLISHED",
        createdAt: "2025-01-12",
    },
    {
        id: "post_3",
        title: "TypeScript Generics: When and How to Use Them",
        slug: "typescript-generics-guide",
        excerpt: "Master TypeScript generics with practical examples for real-world applications.",
        content: "Generics in TypeScript allow you to create reusable components that work with multiple types while maintaining type safety. They're particularly useful when building utility functions, data structures, or APIs that need to handle various data types. By using generics, you avoid the 'any' type and provide better developer experience through intelligent code completion.",
        coverImage: "/images/typescript-generics.png",
        authorId: "user_2",
        status: "PUBLISHED",
        createdAt: "2025-01-15",
    },
    {
        id: "post_4",
        title: "Next.js 14 App Router: A Complete Migration Guide",
        slug: "nextjs-14-app-router-migration",
        excerpt: "Step-by-step guide to migrating from Pages Router to App Router.",
        content: "The App Router in Next.js 14 introduces significant improvements over the Pages Router, including built-in support for React Server Components and improved data fetching patterns. Migration requires understanding the new file-based routing system and adapting your components to leverage server-side rendering benefits. Many developers report performance improvements of 30-40% after successful migration.",
        coverImage: "/images/nextjs-14.png",
        authorId: "user_3",
        status: "PUBLISHED",
        createdAt: "2025-01-18",
    },
    {
        id: "post_5",
        title: "Building Real-time Apps with Socket.io and React",
        slug: "real-time-apps-socketio-react",
        excerpt: "Create a live chat application using Socket.io, Node.js, and React.",
        content: "Socket.io enables bidirectional, real-time communication between web clients and servers. When combined with React, you can build interactive features like live chat, notifications, or collaborative editing tools. The library handles reconnection logic and fallback options automatically, making it more reliable than raw WebSockets for production applications.",
        coverImage: "/images/socketio-chat.png",
        authorId: "user_1",
        status: "PUBLISHED",
        createdAt: "2025-01-20",
    },
    {
        id: "post_6",
        title: "GraphQL vs REST: Choosing the Right API Architecture",
        slug: "graphql-vs-rest-comparison",
        excerpt: "In-depth comparison of GraphQL and REST APIs with use cases.",
        content: "REST has been the dominant API architecture for years, offering simplicity and cacheability through HTTP methods. GraphQL, developed by Facebook, provides more flexibility by allowing clients to request exactly the data they need. While GraphQL reduces over-fetching and under-fetching, it introduces complexity in caching and requires different tooling compared to traditional REST APIs.",
        coverImage: "/images/graphql-rest.png",
        authorId: "user_4",
        status: "PUBLISHED",
        createdAt: "2025-01-22",
    },
    {
        id: "post_7",
        title: "Tailwind CSS Best Practices for Large Projects",
        slug: "tailwind-css-best-practices",
        excerpt: "Organize and scale your Tailwind CSS in enterprise applications.",
        content: "As Tailwind projects grow, maintaining consistency becomes crucial. Using design tokens, establishing a component-first approach, and leveraging the @apply directive strategically can prevent CSS bloat. Implementing a consistent spacing scale and color palette early in the project ensures your design system remains maintainable across multiple teams and components.",
        coverImage: "/images/tailwind-css.png",
        authorId: "user_2",
        status: "PUBLISHED",
        createdAt: "2025-01-25",
    },
    {
        id: "post_8",
        title: "Serverless Functions with AWS Lambda and Node.js",
        slug: "serverless-functions-aws-lambda",
        excerpt: "Build and deploy serverless functions for scalable applications.",
        content: "AWS Lambda allows you to run code without provisioning or managing servers, paying only for the compute time you consume. When combined with Node.js, you can create highly scalable APIs and background processing tasks. Proper cold start management and efficient dependency loading are key considerations for optimizing Lambda performance in production environments.",
        coverImage: "/images/aws-lambda.png",
        authorId: "user_5",
        status: "PUBLISHED",
        createdAt: "2025-01-28",
    },
    {
        id: "post_9",
        title: "React Performance Optimization Techniques",
        slug: "react-performance-optimization",
        excerpt: "Advanced techniques to improve React application performance.",
        content: "React applications can suffer performance issues from unnecessary re-renders, large bundle sizes, and inefficient data fetching. Implementing React.memo, useMemo, and useCallback hooks strategically can prevent expensive computations. Code splitting with React.lazy and optimizing images can significantly improve initial load times and overall user experience.",
        coverImage: "/images/react-performance.png",
        authorId: "user_3",
        status: "PUBLISHED",
        createdAt: "2025-01-30",
    },
    {
        id: "post_10",
        title: "Docker for JavaScript Developers",
        slug: "docker-for-javascript-developers",
        excerpt: "Containerize your Node.js and React applications with Docker.",
        content: "Docker containers provide consistent environments across development, testing, and production stages. For JavaScript applications, multi-stage builds can dramatically reduce image sizes by separating build dependencies from runtime dependencies. Proper layer caching strategies in Dockerfiles can speed up CI/CD pipelines and ensure reproducible builds across different environments.",
        coverImage: "/images/docker-node.png",
        authorId: "user_1",
        status: "PUBLISHED",
        createdAt: "2025-02-02",
    },
    {
        id: "post_11",
        title: "Building Accessible Web Applications",
        slug: "web-accessibility-guide",
        excerpt: "Essential accessibility practices for modern web development.",
        content: "Web accessibility ensures that people with disabilities can perceive, understand, navigate, and interact with your applications. Implementing proper ARIA labels, semantic HTML, keyboard navigation, and sufficient color contrast are fundamental requirements. Regular automated testing with tools like axe-core combined with manual testing by actual users provides the most comprehensive accessibility coverage.",
        coverImage: "/images/web-accessibility.png",
        authorId: "user_4",
        status: "PUBLISHED",
        createdAt: "2025-02-05",
    },
    {
        id: "post_12",
        title: "Testing React Components with Jest and Testing Library",
        slug: "testing-react-components",
        excerpt: "Comprehensive guide to unit testing React applications.",
        content: "React Testing Library encourages testing components the way users interact with them, rather than testing implementation details. Jest provides a comprehensive test runner with built-in assertions and mocking capabilities. Combining these tools creates a robust testing strategy that gives confidence when refactoring code and prevents regression bugs in complex user interfaces.",
        coverImage: "/images/react-testing.png",
        authorId: "user_2",
        status: "PUBLISHED",
        createdAt: "2025-02-08",
    },
    {
        id: "post_13",
        title: "MongoDB Aggregation Pipeline Explained",
        slug: "mongodb-aggregation-pipeline",
        excerpt: "Master complex data transformations with MongoDB aggregation.",
        content: "The MongoDB aggregation pipeline processes documents through a series of stages, transforming them into aggregated results. Each stage performs operations like filtering, grouping, sorting, or reshaping documents. This powerful feature enables complex analytics and data transformations directly in the database, reducing the need for extensive application-level processing.",
        coverImage: "/images/mongodb-aggregation.png",
        authorId: "user_5",
        status: "PUBLISHED",
        createdAt: "2025-02-10",
    },
    {
        id: "post_14",
        title: "State Management in 2025: Zustand vs Redux Toolkit",
        slug: "zustand-vs-redux-toolkit",
        excerpt: "Comparing modern state management solutions for React.",
        content: "Redux Toolkit simplifies traditional Redux by reducing boilerplate and providing sensible defaults, while Zustand offers a minimalistic approach with hooks-based API. Zustand typically requires less code and has a smaller bundle size, making it appealing for smaller projects. Redux Toolkit remains popular in enterprise applications due to its extensive ecosystem and time-tested patterns.",
        coverImage: "/images/state-management.png",
        authorId: "user_3",
        status: "PUBLISHED",
        createdAt: "2025-02-12",
    },
    {
        id: "post_15",
        title: "CI/CD Pipeline for Frontend Applications",
        slug: "ci-cd-pipeline-frontend",
        excerpt: "Set up automated testing and deployment for your frontend projects.",
        content: "A well-structured CI/CD pipeline automates testing, building, and deployment of frontend applications. GitHub Actions, GitLab CI, or CircleCI can run tests, perform linting, build artifacts, and deploy to platforms like Vercel or Netlify. Implementing proper branch protection rules and automated preview deployments for pull requests significantly improves development workflow and code quality.",
        coverImage: "/images/ci-cd-frontend.png",
        authorId: "user_1",
        status: "PUBLISHED",
        createdAt: "2025-02-15",
    },
    {
        id: "post_16",
        title: "WebSockets vs Server-Sent Events: Real-time Communication",
        slug: "websockets-vs-server-sent-events",
        excerpt: "Choosing the right real-time communication protocol for your needs.",
        content: "WebSockets provide full-duplex communication channels over a single TCP connection, ideal for interactive applications like chat or gaming. Server-Sent Events (SSE) offer a simpler, unidirectional approach for server-to-client updates, perfect for notifications or live feeds. SSE has built-in reconnection support and works over standard HTTP, while WebSockets require a dedicated protocol upgrade.",
        coverImage: "/images/realtime-protocols.png",
        authorId: "user_4",
        status: "PUBLISHED",
        createdAt: "2025-02-18",
    },
    {
        id: "post_17",
        title: "Microservices with Node.js: Patterns and Pitfalls",
        slug: "microservices-nodejs-patterns",
        excerpt: "Architecting scalable microservices with Node.js.",
        content: "Microservices architecture decomposes applications into small, independent services that communicate via APIs. Node.js excels in this environment due to its non-blocking I/O model and lightweight nature. However, distributed systems introduce challenges in service discovery, data consistency, and debugging that require careful planning and appropriate tooling to address effectively.",
        coverImage: "/images/node-microservices.png",
        authorId: "user_5",
        status: "PUBLISHED",
        createdAt: "2025-02-20",
    },
];